import Collapsible from '@/components/Collapsible';

# Getting Started On Your Own App

### Requirements

To use Kardinal, you will need a development Kubernetes cluster with Istio installed. You will also need `kubectl` installed on your machine, pointing to your cluster.

If you'd like to use a local Kubernetes cluster to try out Kardinal, you can refer to the first step of our [demo app guide](getting-started/demo) to get a local minikube Kubernetes cluster up and running.

To work with Kardinal, your application needs to meet two main requirements:

1. You can define a dependency graph of your services
2. You have distributed tracing and can integrate with Kardinal tracing (more details provided below)

If you can't yet fulfill these requirements, our [demo app](getting-started/demo) is a great way to explore Kardinal until those two prerequesites are met.

If you have distributed tracing in your application, and you're able to define dependencies per service in your deployment spec, you can install Kardinal today.

### Part 1: Add Kardinal Annotations to your Manifests

Kardinal uses annotations on your Kubernetes manifests to get an understanding of your system and how to handle its various dev and testing workflow needs.

To demonstrate how to modify your Kubernetes manifest for Kardinal, we'll start with an example Kubernetes manifest and incrementally add Kardinal annotations to it.

Here's the Kubernetes manifest for an [online boutique store](https://github.com/kurtosis-tech/new-obd) demo:

<Collapsible title="Demo Application Kubernetes Manifest">

```yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: cartservice-v1
  labels:
    app: cartservice
    version: v1
spec:
  selector:
    matchLabels:
      app: cartservice
      version: v1
  template:
    metadata:
      labels:
        app: cartservice
        version: v1
    spec:
      terminationGracePeriodSeconds: 5
      containers:
        - name: server
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - all
            privileged: false
            readOnlyRootFilesystem: true
          image: cartservice
          ports:
            - containerPort: 8090
          readinessProbe:
            httpGet:
              path: /health
              port: 8090
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
            successThreshold: 1
          livenessProbe:
            httpGet:
              path: /health
              port: 8090
            initialDelaySeconds: 15
            periodSeconds: 20
            timeoutSeconds: 5
            failureThreshold: 3
          env:
            - name: PORT
              value: "8090"
            - name: DB_USERNAME
              value: "postgresuser"
            - name: POSTGRES_USER
              value: "postgresuser"
            - name: POSTGRES_PASSWORD
              value: "postgrespass"
           volumeMounts:
            - name: DB_HOST
              value: "postgres"
            - name: DB_PORT
              value: "5432"
            - name: DB_NAME
              value: "cart"
---
apiVersion: v1
kind: Service
metadata:
  name: cartservice
  labels:
    app: cartservice
    version: v1
spec:
  type: ClusterIP
  selector:
    app: cartservice
  ports:
    - name: http
      port: 8090
      targetPort: 8090
      protocol: TCP
      appProtocol: HTTP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-v1
  labels:
    app: frontend
    version: v1
spec:
  selector:
    matchLabels:
      app: frontend
      version: v1
  template:
    metadata:
      labels:
        app: frontend
        version: v1
      annotations:
        sidecar.istio.io/rewriteAppHTTPProbers: "true"
    spec:
      containers:
        - name: server
          image: leoporoli/newobd-frontend:0.0.6
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          readinessProbe:
            initialDelaySeconds: 10
            httpGet:
              path: "/_healthz"
              port: 8080
              httpHeaders:
                - name: "Cookie"
                  value: "shop_session-id=x-readiness-probe"
          livenessProbe:
            initialDelaySeconds: 10
            httpGet:
              path: "/_healthz"
              port: 8080
              httpHeaders:
                - name: "Cookie"
                  value: "shop_session-id=x-liveness-probe"
          env:
            - name: ADDRESS
              value: ":8080"
            - name: FREECURRENCYAPIKEY
              value: "fca_live_nFVVF8CvfxqJhzMHB4N2x1NH7ffVVPwZr9hg3iNl"
            - name: CARTSERVICEHOST
              value: cartservice
            - name: PRODUCTCATALOGSERVICEHOST
              value: productcatalogservice

---
apiVersion: v1
kind: Service
metadata:
  name: frontend
  labels:
    app: frontend
    version: v1
spec:
  type: ClusterIP
  selector:
    app: frontend
  ports:
    - name: http
      port: 80
      protocol: TCP
      appProtocol: HTTP
      targetPort: 8080

---
apiVersion: v1
kind: Service
metadata:
  name: frontend-external
spec:
  type: LoadBalancer
  selector:
    app: frontend
  ports:
    - name: http
      port: 80
      targetPort: 8080
      protocl: TCP
      appProtocol: HTTP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres-v1
  labels:
    app: postgres
    version: v1
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
      version: v1
  template:
    metadata:
      labels:
        app: postgres
        version: v1
    spec:
      containers:
        - name: postgres
          image: 'postgres:14'
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 5432
          env:
            - name: POSTGRES_DB
              value: "cart"
            - name: POSTGRES_USER
              value: "postgresuser"
            - name: POSTGRES_PASSWORD
              value: "postgrespass"
          volumeMounts:
            - mountPath: /var/lib/postgresql/data
              name: postgres-data
      volumes:
        - name: postgres-data
          emptyDir: {}

---
apiVersion: v1
kind: Service
metadata:
  name: postgres
  labels:
    app: postgres
    version: v1
spec:
  type: ClusterIP
  ports:
    - name: tcp
      port: 5432
      targetPort: 5432
  selector:
    app: postgres
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: productcatalogservice-v1
  labels:
    app: productcatalogservice
    version: v1
spec:
  selector:
    matchLabels:
      app: productcatalogservice
      version: v1
  template:
    metadata:
      labels:
        app: productcatalogservice
        version: v1
    spec:
      terminationGracePeriodSeconds: 5
      containers:
        - name: server
          image: productcatalogservice
          ports:
            - containerPort: 8070
          readinessProbe:
            httpGet:
              path: /health
              port: 8070
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
            successThreshold: 1
          livenessProbe:
            httpGet:
              path: /health
              port: 8070
            initialDelaySeconds: 15
            periodSeconds: 20
            timeoutSeconds: 5
            failureThreshold: 3
          env:
            - name: PORT
              value: "8070"
---
apiVersion: v1
kind: Service
metadata:
  name: productcatalogservice
  labels:
    app: productcatalogservice
    version: v1
spec:
  type: ClusterIP
  selector:
    app: productcatalogservice
  ports:
    - name: http
      port: 8070
      targetPort: 8070
      protocol: TCP
      appProtocol: http
```
</Collapsible>

This application consists of:

1. A product catalog service to provide information about available products available
2. A cart service to manage a users cart
3. A Postgres database for storing cart information
3. A frontend for the storefront that communicates with the cart service and product catalog service to display info

Now, let's add some annotations. There are a few different annotations we'll need to add to our application:
1. *`kardinal.dev.service/dependencies`* to specify the dependency graph
2. *`kardinal.dev.service/ingress`* and *`kardinal.dev.service/host`* to specify the ingress point
4. *`kardinal.dev.service/stateful`* to specify what services hold state
5. *`kardinal.dev.service/plugins`* to specify plugin handlers for external and stateful services

First, we'll add the *`kardinal.dev.service/dependencies`* annotation to the services that depend on other services.

To do this, add the *`kardinal.dev.service/dependencies`* annotation to a service with a comma-separated list of the services that it depends on and the protocol it uses to talk to that service. Currently, the annotations supports `tcp` and `http` for protocols.

Here is how we'd update our boutique store application to specify its dependency graph:

```yaml

  ...
  name: cartservice
  labels:
    app: cartservice
    version: v1
  annotations:
    kardinal.dev.service/dependencies: "postgres:tcp"
  ...
  metadata:
    name: frontend
    labels:
      app: frontend
      version: v1
    annotations:
      kardinal.dev.service/dependencies: "productcatalogservice:http,cartservice:http"
  ...
```

Now, we'll annotate our ingress service with *`kardinal.dev.service/ingress`* and *`kardinal.dev.service/host`*.

Kardinal expects there to be exactly one service that acts as an entrypoint into the cluster, usually an load balancer or gateway of some sort that routes traffic into the cluster accordingly.

For our application, we're using a simple `LoadBalancer` that routes all traffic to our frontend so we'll define that as our ingress and use the *`kardinal.dev.service/host`* annotation to give it a hostname we can use to access it.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: frontend-external
  annotations:
    kardinal.dev.service/ingress: "true"
    kardinal.dev.service/host: "prod.app.localhost"
spec:
  type: LoadBalancer
  selector:
    app: frontend
  ports:
    - name: http
      port: 80
      targetPort: 8080
      protocl: TCP
      appProtocol: HTTP
```

Next, we'll add the *`kardinal.dev.service/stateful`* annotation to the services that hold state.

Kardinal needs to know what services in the cluster hold state or data to be persisted. These are usually databases, caches, and message queues - but it could also be backend services that accrues state in memory. Either way, we tell Kardinal about these via the `stateful` annotation.

The only stateful application in our application is the `postgres` database that stores cart information.

```yaml

apiVersion: v1
kind: Service
metadata:
  name: postgres
  labels:
    app: postgres
    version: v1
  annotations:
    kardinal.dev.service/stateful: "true"
```

Finally, we'll add the *`kardinal.dev.service/plugins`* annotation to the services that need it.

To manage persistent state in your system for creating flows, Kardinal uses a plugin ecosystem. These plugins inform Kardinal on how to handle stateful or external applications when creating flows. For more information on plugins, refer to the [plugins doc](../../concepts/plugins).

Our application will leverage the [postgres-seed-plugin](https://github.com/kurtosis-tech/postgres-seed-plugin) to handle our `postgres` database. Anytime a flow is created involving the postgres database, this plugin will create a dev version of the database seeded with a provided script. The args for it can be found [here](https://github.com/kurtosis-tech/postgres-seed-plugin/blob/d2ff1bef180caa6345b6a890673f3a83a347bce2/main.py#L3), after the `flow_uuid` kwaarg.

We'll add this plugin to the `postgres` service, specifying the github repo with the plugin logic and args that the plugin expects: 

```yaml
apiVersion: v1
kind: Service
metadata:
  name: postgres
  labels:
    app: postgres
    version: v1
  annotations:
    kardinal.dev.service/stateful: "true"
    kardinal.dev.service/plugins: |
      - name: github.com/kurtosis-tech/postgres-seed-plugin
        args:
          seed_script: "create table if not exists public.items( id bigserial primary key, created_at timestamp with time zone, updated_at timestamp with time zone, deleted_at timestamp with time zone, user_id    text, product_id text, quantity   integer); INSERT INTO public.items (id, created_at, updated_at, deleted_at, user_id, product_id, quantity) VALUES (1, '2024-08-02 13:02:07.656104 +00:00', '2024-08-02 13:02:07.656104 +00:00', null, '0494c5e0-dde0-48fa-a6d8-f7962f5476bf', '66VCHSJNUP', 1); INSERT INTO public.items (id, created_at, updated_at, deleted_at, user_id, product_id, quantity) VALUES (2, '2024-08-02 13:02:10.891407 +00:00', '2024-08-02 13:02:10.891407 +00:00', null, '0494c5e0-dde0-48fa-a6d8-f7962f5476bf', '2ZYFJ3GM2N', 1); SELECT setval('items_id_seq', (SELECT MAX(id) FROM items));"
          db_name: "cart"
          db_user: "postgresuser"
          db_password: "postgrespass"
```
Note, the `seed_script` arg is a single line as there is a limitation in current Kardinal which requires arguments to be a single line, we are working on a fix.
Additionally, we can use plugins to handle external services like third party APIs (eg. Stripe, Mailchimp) and managed databases and queues (eg. AWS Postgres).

Our frontend service depends on the [Free Currency API](https://freecurrencyapi.com/). Luckily, dev versions of our frontend will communicate with this API in the same way, but we can still use a plugin + plugin annotation so that Kardinal will display the external API in the dashboard.

We add external service plugins as an annotation on the service that depends on it in the manifest similar to the stateful plugin, but we'll add the `type` and `servicename` fields.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: frontend
  labels:
    app: frontend
    version: v1
  annotations:
    kardinal.dev.service/dependencies: "productcatalogservice:http,cartservice:http"
    kardinal.dev.service/plugins: |
      - name: github.com/kurtosis-tech/free-currency-api-plugin
        type: external
        servicename: free-currency-api
        args:
          api_key: fca_live_VKZlykCWEiFcpBHnw74pzd4vLi04q1h9JySbVHDF
```

Congrats! You've added all the annotations Kardinal needs to work with your application. We're halfway there.

> ## ⚠️ Warning: Make sure HTTP ports are marked with appProtocol
>
> Please mark services that use HTTP with `appProtocol: HTTP` and list them as the first port in your configuration.
>
> Example:
> ```yaml
> apiVersion: v1
> kind: Service
> metadata:
>   name: productcatalogservice
>   labels:
>     app: productcatalogservice
>     version: v1
> spec:
>   type: ClusterIP
>   selector:
>    app: productcatalogservice
>   ports:
>    - name: http
>      port: 8070
>      targetPort: 8070
>      protocol: TCP
>      appProtocol: http
> ```
>
> The first port in a given service needs to be marked with `appProtocol: HTTP`; this is a limitation that we are actively working on.

The manifest should all together look like:

<Collapsible title="Fully Annotated Demo Kubernetes Manifest">

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cartservice-v1
  labels:
    app: cartservice
    version: v1
spec:
  selector:
    matchLabels:
      app: cartservice
      version: v1
  template:
    metadata:
      labels:
        app: cartservice
        version: v1
    spec:
      terminationGracePeriodSeconds: 5
      containers:
        - name: server
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - all
            privileged: false
            readOnlyRootFilesystem: true
            image: leoporoli/newobd-cartservice:0.0.3
            imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8090
          readinessProbe:
            httpGet:
              path: /health
              port: 8090
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
            successThreshold: 1
          livenessProbe:
            httpGet:
              path: /health
              port: 8090
            initialDelaySeconds: 15
            periodSeconds: 20
            timeoutSeconds: 5
            failureThreshold: 3
          env:
            - name: PORT
              value: "8090"
            - name: DB_USERNAME
              value: "postgresuser"
            - name: DB_PASSWORD
              value: "postgrespass"
            - name: DB_HOST
              value: "postgres"
            - name: DB_PORT
              value: "5432"
            - name: DB_NAME
              value: "cart"
---
apiVersion: v1
kind: Service
metadata:
  name: cartservice
  labels:
    app: cartservice
    version: v1
  annotations:
    kardinal.dev.service/dependencies: "postgres:tcp"    
spec:
  type: ClusterIP
  selector:
    app: cartservice
  ports:
    - name: http
      port: 8090
      targetPort: 8090
      protocol: TCP
      appProtocol: HTTP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-v1
  labels:
    app: frontend
    version: v1
spec:
  selector:
    matchLabels:
      app: frontend
      version: v1
  template:
    metadata:
      labels:
        app: frontend
        version: v1
      annotations:
        sidecar.istio.io/rewriteAppHTTPProbers: "true"
    spec:
      containers:
        - name: server
          image: frontend
          ports:
            - containerPort: 8080
          readinessProbe:
            initialDelaySeconds: 10
            httpGet:
              path: "/_healthz"
              port: 8080
              httpHeaders:
                - name: "Cookie"
                  value: "shop_session-id=x-readiness-probe"
          livenessProbe:
            initialDelaySeconds: 10
            httpGet:
              path: "/_healthz"
              port: 8080
              httpHeaders:
                - name: "Cookie"
                  value: "shop_session-id=x-liveness-probe"
          env:
            - name: ADDRESS
              value: ":8080"
            - name: FREECURRENCYAPIKEY
              value: "fca_live_nFVVF8CvfxqJhzMHB4N2x1NH7ffVVPwZr9hg3iNl"
            - name: CARTSERVICEHOST
              value: cartservice
            - name: PRODUCTCATALOGSERVICEHOST
              value: productcatalogservice

---
apiVersion: v1
kind: Service
metadata:
  name: frontend
  labels:
    app: frontend
    version: v1
  annotations:
    kardinal.dev.service/dependencies: "productcatalogservice:http,cartservice:http"
    kardinal.dev.service/plugins: |
      - name: github.com/kurtosis-tech/free-currency-api-plugin
        type: external
        servicename: free-currency-api
        args:
          api_key: fca_live_VKZlykCWEiFcpBHnw74pzd4vLi04q1h9JySbVHDF      
spec:
  type: ClusterIP
  selector:
    app: frontend
  ports:
    - name: http
      port: 80
      protocol: TCP
      appProtocol: HTTP
      targetPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: frontend-external
  annotations:
    kardinal.dev.service/ingress: "true"
    kardinal.dev.service/host: "prod.app.localhost"  
spec:
  type: LoadBalancer
  selector:
    app: frontend
  ports:
    - name: http
      port: 80
      targetPort: 8080
      protocol: TCP
      appProtocol: HTTP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres-v1
  labels:
    app: postgres
    version: v1
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
      version: v1
  template:
    metadata:
      labels:
        app: postgres
        version: v1
    spec:
      containers:
        - name: postgres
          image: 'postgres:14'
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 5432
          env:
            - name: POSTGRES_DB
              value: "cart"
            - name: POSTGRES_USER
              value: "postgresuser"
            - name: POSTGRES_PASSWORD
              value: "postgrespass"
          volumeMounts:
            - mountPath: /var/lib/postgresql/data
              name: postgres-data
      volumes:
        - name: postgres-data
          emptyDir: {}

---
apiVersion: v1
kind: Service
metadata:
  name: postgres
  labels:
    app: postgres
    version: v1
  annotations:
    kardinal.dev.service/stateful: "true"
    kardinal.dev.service/plugins: |
      - name: github.com/kurtosis-tech/postgres-seed-plugin
        args:
          seed_script: "create table if not exists public.items( id bigserial primary key, created_at timestamp with time zone, updated_at timestamp with time zone, deleted_at timestamp with time zone, user_id    text, product_id text, quantity   integer); INSERT INTO public.items (id, created_at, updated_at, deleted_at, user_id, product_id, quantity) VALUES (1, '2024-08-02 13:02:07.656104 +00:00', '2024-08-02 13:02:07.656104 +00:00', null, '0494c5e0-dde0-48fa-a6d8-f7962f5476bf', '66VCHSJNUP', 1); INSERT INTO public.items (id, created_at, updated_at, deleted_at, user_id, product_id, quantity) VALUES (2, '2024-08-02 13:02:10.891407 +00:00', '2024-08-02 13:02:10.891407 +00:00', null, '0494c5e0-dde0-48fa-a6d8-f7962f5476bf', '2ZYFJ3GM2N', 1); SELECT setval('items_id_seq', (SELECT MAX(id) FROM items));"
          db_name: "cart"
          db_user: "postgresuser"
          db_password: "postgrespass"    
spec:
  type: ClusterIP
  ports:
    - name: tcp
      port: 5432
      targetPort: 5432
  selector:
    app: postgres
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: productcatalogservice-v1
  labels:
    app: productcatalogservice
    version: v1
spec:
  selector:
    matchLabels:
      app: productcatalogservice
      version: v1
  template:
    metadata:
      labels:
        app: productcatalogservice
        version: v1
    spec:
      terminationGracePeriodSeconds: 5
      containers:
        - name: server
          image: productcatalogservice
          ports:
            - containerPort: 8070
          readinessProbe:
            httpGet:
              path: /health
              port: 8070
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
            successThreshold: 1
          livenessProbe:
            httpGet:
              path: /health
              port: 8070
            initialDelaySeconds: 15
            periodSeconds: 20
            timeoutSeconds: 5
            failureThreshold: 3
          env:
            - name: PORT
              value: "8070"
---
apiVersion: v1
kind: Service
metadata:
  name: productcatalogservice
  labels:
    app: productcatalogservice
    version: v1
spec:
  type: ClusterIP
  selector:
    app: productcatalogservice
  ports:
    - name: http
      port: 8070
      targetPort: 8070
      protocol: TCP
      appProtocol: HTTP
```
</Collapsible>

## Part 2: Kardinal Tracing

To support multiple flows utilizing the same services, Kardinal uses trace ids on requests that determine which versions of services in a cluster to route traffic to. All applications communicating using Kardinal need to forward the `X-Kardinal-Trace-Id` header along with the trace id from the incoming request onto all outgoing requests. Applications that are non-http will be duplicated and Kardinal will handle routing to duplicated versions. To read more about trace ids and how the mechanism works read here:

Here is an example of how we can add logic to attach Kardinal trace ids to our application. 

### Frontend Boutique Store

The frontend is a Golang HTTP server serving html and communicates with the `cartservice` and `productcatalog` service over HTTP via REST APIs following. Thus, the frontend will need to retrieve the trace id header from incoming requests and add it as a header to outgoing requests to the `cartservice` and `productservice`.


To accomplish this, we'll create a middleware function called `getSetTraceIdHeaderRequestEditorFcn` that retrieves the trace id from an incoming requests, and returns a function that sets that id value as the `X-Kardinal-Trace-Id` header on a downstream separate request.

```go
const (
	KardinalTraceIdHeaderKey = "X-Kardinal-Trace-Id"
)

func getSetTraceIdHeaderRequestEditorFcn(upsTreamRequest *http.Request) func(ctx context.Context, req *http.Request) error {

	traceID := upsTreamRequest.Header.Get(consts.KardinalTraceIdHeaderKey)

	var setKardinalReqEditorFcn = func(ctx context.Context, req *http.Request) error {
		req.Header.Set(consts.KardinalTraceIdHeaderKey, traceID)
		return nil
	}

	return setKardinalReqEditorFcn
}
```

We call this function in every handler. The returned set function then gets passed as a [`RequestEditorFn`](https://github.com/kurtosis-tech/new-obd/blob/57bd02df92afd140327aa1a27924cc8bb2d9cd00/src/cartservice/api/http_rest/client/client.gen.go#L42) (a parameter provided on OpenAPI-generated Rest API clients for callbacks modifying requests) on all outgoing requests. For example, in the handler for the [/products](https://github.com/kurtosis-tech/new-obd/blob/57bd02df92afd140327aa1a27924cc8bb2d9cd00/src/frontend/handlers.go#L117) endpoint - we call `getSetTraceIdHeaderRequestEditorFcn` once, and pass it to outgoing requests to services in our cluster. This way, the Kardinal trace id header gets added to the request and Kardinal will be able to route the request to the proper versions of services in a flow!

```go
func (server *frontendServer) productHandler(w http.ResponseWriter, r *http.Request) {
	setKardinalReqEditorFcn := getSetTraceIdHeaderRequestEditorFcn(r)
	
	productResponse, err := server.productCatalogService.GetProductsWithResponse(r.Context(), setKardinalReqEditorFcn)
	
	...
	cartResponse, err := fe.cartService.GetCartUserIdWithResponse(r.Context(), userID, setKardinalReqEditorFcn)
	...
}
```

Details will differ for different stacks and languages but the high level idea is to forward the `X-Kardinal-Trace-Id` header value from incoming HTTP requests to all internal outgoing HTTP requests! If you have questions on integrating Kardinal tracing onto your stack, please reach out to us.


Note: Currently, trace IDs are only forwarded for http servers. For servers not communicating using HTTP - Kardinal will detect this (using the `kardinal.dev.service/dependencies` annotation) and duplicate the service in the flow to ensure isolation.

## Part 3: Deploy!

Okay, now that we've got Kardinal integrated, let's deploy our application.

1. Install Kardinal CLI
    
    ```yaml
    curl get.kardinal.dev -sL | sh
    ```
    
2. Deploy the manager to your cluster
    
    Make sure your `kubectl` is set to the right context for the cluster you want to deploy to. 
    Then, run:

    
    ```yaml
    kardinal manager deploy kloud-kontrol
    ```
    
3. Deploy your application
    
    ```yaml
    kardinal deploy --k <path-to-k8s-manifest-annotated-with-Kardinal>
    ```
    
    You should now be able to view your application in the Kardinal dashboard!
    
    ```yaml
    https://app.kardinal.dev/<tenant-id-output-by-CLI>/traffic-configuration
    ```
    
    or run `kardinal dashboard` to get the link!
    
4. Create a flow! Pick a service in your application to test a dev image on
    
    ```yaml
    kardinal flow create frontend-service-name your/new-frontend-image:dev
    ```
    ---
    eg.
    ```bash
    kardinal flow create frontend leoporoli/newobd-frontend:dev
    INFO[0000] Using tenant UUID 483e3371-ec18-40ca-aaee-54df597d1fd2 
    INFO[0000] Creating service frontend with image leoporoli/newobd-frontend:dev in development mode... 
    Flow "dev-qlm1214pgt" created. Access it on:
    🌐 http://dev-qlm1214pgt.app.localhost
    
    ```
    
5. View the flow by returning to the `kardinal dashboard`!
    
    You should now see both prod and dev versions of the service you created a flow on, along with dev versions of services Kardinal determined needed to be duplicated to provide isolation within the cluster (eg. a dev database). These dev versions should have the `flow-id` output by the command next to them.
    
6. Interact with the new flow by `kardinal gateway <flow-id>`! 
    
    ```bash
    $ kardinal gateway dev-qlm1214pgt
    INFO[0000] Using tenant UUID 483e3371-ec18-40ca-aaee-54df597d1fd2 
    2024/08/07 13:50:52 Starting gateway for host: dev-qlm1214pgt.app.localhost
    2024/08/07 13:50:52 All pods in namespace prod are ready and flowId dev-qlm1214pgt found
    2024/08/07 13:50:52 Proxy server for host dev-qlm1214pgt.app.localhost started on http://localhost:9060
    
    ```
    
    This command will open a gateway to the entry point - whatever service of your application was annotated with the `kardinal.dev.service/ingress` annotation. Whether the service is a frontend, or api - you can access the dev flow by making requests to the returned endpoint. These requests will flow through your system through only the dev versions of services in for that flow.
