export const metadata = {
  title: "Kardinal Docs | Architecture",
};

# Architecture

Kardinal depends on three elements of your Kubernetes deployment::

1. A dependency graph - every service defines its dependencies, including external APIs it uses to store or retrieve data.
2. A service mesh, like Istio.
3. Distributed tracing

With these elements, Kardinal can effectively instrument the lightest-weight multitenancy possible within your cluster.

On the Kardinal sie, an in-cluster service called the `Kardinal Manager` is responsible for reading the dependency graph annotations and managing the service mesh to implement routing rules per request. The existing distributed tracing infrastucture in your application is used to keep track of requests as they trace their way through the cluster.

To manage any persisted state in your cluster, Kardinal relies on a plugin ecosystem that define, service-by-service, how to properly share state between environments, or how to spin up new, empty "dev" versions of given stateful services.

There are two kinds of plugins:

- _Stateful service plugins_

  Define state access modes for stateful services that are deployed and managed via Kubernetes, like a Postgres database.

- _External service plugins_

  Define state access modes for external services that are not managed by Kubernetes, like Stripe or Twilio.

These plugins can be installed with Kardinal, enabling you to properly configure your flows to maximally reuse any persisted state in your application across development workflows, allocating new development instances of stateful services whenever necessary.

